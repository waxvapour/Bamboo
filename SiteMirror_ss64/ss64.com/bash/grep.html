<!doctype html><html lang="en">

<!-- Mirrored from ss64.com/bash/grep.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Nov 2018 11:39:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="UTF-8">
<meta name=viewport content="width=device-width, initial-scale=1">
<link rel="STYLESHEET" href="../main.css" type="text/css">
<title>grep Man Page - Linux - SS64.com</title>
</head><!-- #BeginLibraryItem "/Library/head_bash.lbi" --><div id="tnav"><ul>
<li class="tbtn"><a href="../index.html"> ( &nbsp;SS64 &nbsp;)</a></li>
<li class="tbtn"><a href="index.html">Linux</a></li>
<li class="tbtn"><a href="syntax.html">Syntax</a></li>
<li><div id="search"><form action="https://www.google.com/search" method="get">
<input type="text" name="q" id="q" size="27" maxlength="255">
<input class="submit" value="Search" id="btn" type="submit">
<input type="hidden" name="sitesearch" value="ss64.com/bash/"></form></div></li>
</ul></div><!-- #EndLibraryItem --><h1>grep</h1> 
<p>Search file(s) for specific text. </p>
<pre>Syntax
      grep [<i>options</i>] <i>PATTERN</i> [<i>FILE</i>...]
<br>      grep [<i>options</i>] [-e <i>PATTERN</i> | -f <i>FILE</i>] [<i>FILE</i>...]

<span class="body">A simple example:</span>
$ grep "Needle in a Haystack" /etc/*

Options
   -A <i>NUM</i>
   --after-context=<i>NUM</i>
       Print <i>NUM</i> lines of trailing context after matching lines.
       Places a line containing -- between contiguous groups of matches. 
   -a
   --text
       Process a binary file as if it were text; this is equivalent
       to the --binary-files=text option.

   -B <i>NUM
  </i> --before-context=<i>NUM</i>
       Print <i>NUM</i> lines of leading context before matching lines.
       Places a line containing -- between contiguous groups of matches.

   -b
   --byte-offset
       Print the byte offset within the input file before each line of output. 
   --binary-files=<i>TYPE</i>
       If the first few bytes of a file indicate that the file contains binary data, assume 
       that the file is of type <i>TYPE</i>. By default, <i>TYPE</i> is binary, and grep normally outputs
       either a one-line message saying that a binary file matches, or no message if there
       is no match. If <i>TYPE</i> is without-match, grep assumes that a binary file does not match;
       this is equivalent to the -I option. If <i>TYPE</i> is text, grep processes a binary file as
       if it were text; this is equivalent to the -a option.
       Warning: grep --binary-files=text might output binary garbage, which can have nasty
       side effects if the output is a terminal and if the terminal driver interprets some
       of it as commands. 
   --colour[=<i>WHEN</i>]
   --color[=<i>WHEN</i>]
       Surround the matching string with the marker from the GREP_COLOR environment variable.
       WHEN can be 'never', 'always', or 'auto' e.g. --color=always<br>       By default the matched text will be colored red.
       If grep is made to match several strings, all of the matches will be colored, one exception
       is the regex ^ (match beginning of every line), the beginning of a line has no length so will
       not be coloued.
       So to return all lines and colour only matches: egrep --color=always '^|string1|string2'

   -C <i>NUM</i>
   --context=<i>NUM</i>
       Print NUM lines of output context.
       Places a line containing -- between contiguous groups of matches. 
   -c
   --count
       Suppress normal output; instead print a count of matching lines for each input file.
       With the -v, --invert-match option (see below), count non-matching lines.

   -D <i>ACTION</i>
   --devices=<i>ACTION</i>
       If an input file is a device, FIFO or socket, use <i>ACTION</i> to process it.
       By default, <i>ACTION</i> is read, which means that devices are read just as if they were
       ordinary files. If <i>ACTION</i> is skip, devices are silently skipped.

   -d <i>ACTION</i>
   --directories=<i>ACTION</i>
       If an input file is a directory, use <i>ACTION</i> to process it.
       By default, <i>ACTION</i> is read, which means that directories are read just as if they
       were ordinary files. If <i>ACTION</i> is skip, directories are silently skipped.
       If <i>ACTION</i> is recurse, grep reads all files under each directory, recursively; this
       is equivalent to the -r option.

   -E
   --extended-regexp
       Interpret <i>PATTERN</i> as an <a href="grep-regex.html">extended regular expression</a>.

   -e <i>PATTERN</i>
   --regexp=<i>PATTERN</i>
       Use <i>PATTERN</i> as the pattern; useful to protect patterns beginning with -.

   -F
   --fixed-strings
       Interpret <i>PATTERN</i> as a list of fixed strings, separated by newlines,
       any of which is to be matched.

   -f <i>FILE</i>
   --file=<i>FILE</i>
       Obtain patterns from <i>FILE</i>, one per line. The empty file contains zero
       patterns, and therefore matches nothing.

   -G
   --basic-regexp
       Interpret <i>PATTERN</i> as a <a href="grep-regex.html">basic regular expression</a> This is the default.
 
   -H
   --with-filename
       Print the filename for each match. 
   -h
   --no-filename
       Suppress the prefixing of filenames on output when multiple files are searched. 
   --help
      Output a brief help message.

   -I
      Process a binary file as if it did not contain matching data; this is
      equivalent to the --binary-files=without-match option.
   -i
   --ignore-case
      Ignore case distinctions in both the <i>PATTERN</i> and the input files.

   -L
   --files-without-match
      Suppress normal output; instead print the name of each input file from which
      no output would normally have been printed. The scanning will stop on the first match. 
   -l
   --files-with-matches
      Suppress normal output; instead print the name of each input file from which
      output would normally have been printed. The scanning will stop on the first match.

   -m <i>NUM</i>
   --max-count=<i>NUM</i>
      Stop reading a file after NUM matching lines.
      If the input is standard input from a regular file, and NUM matching lines are
      output, grep ensures that the standard input is positioned to just after the last
      matching line before exiting, regardless of the presence of trailing context lines.
      This enables a calling process to resume a search. When grep stops after <i>NUM</i> matching
      lines, it outputs any trailing context lines.
      When the -c or --count option is also used, grep does not output a count greater
      than <i>NUM</i>. When the -v or --invert-match option is also used, grep stops after
      outputting <i>NUM</i> non-matching lines. 
   --mmap
      If possible, use the mmap(2) system call to read input, instead of the default
      read(2) system call. In some situations, --mmap yields better performance.
      However, --mmap can cause undefined behavior (including core dumps) if an input
      file shrinks while grep is operating, or if an I/O error occurs.

   -n
   --line-number
      Prefix each line of output with the line number within its input file. 

   -o
   --only-matching
       Show only the part of a matching line that matches <i>PATTERN</i>.

   --label=<i>LABEL</i>
       Display input actually coming from standard input as input coming from file <i>LABEL</i>.
       This is especially useful for tools like zgrep, e.g. gzip -cd foo.gz |grep --label=foo something 
   --line-buffered
       Use line buffering, it can be a performance penality.

   -P
   --perl-regexp
       Interpret <i>PATTERN</i> as a Perl regular expression.

   -q
   --quiet, --silent
       Quiet; do not write anything to standard output.
       Exit immediately with zero status if any match is found, even if an error
       was detected. Also see the -s or --no-messages option.

   -R
   -r
   --recursive
       Read all files under each directory, recursively; this is equivalent to the '-d recurse' option. 
       Not all grep implementations support -r and among those that do, the behaviour with symlinks may differ.

   --include=<i>PATTERN</i>
       Recurse in directories only searching file matching <i>PATTERN</i>. 
   --exclude=<i>PATTERN</i>
       Recurse in directories skip file matching <i>PATTERN</i>.
 
   -s
   --no-messages
       Suppress error messages about nonexistent or unreadable files.
       Portability note: unlike GNU grep, traditional grep did not conform to POSIX.2 ,
       because traditional grep lacked a -q option and its -s option behaved like
       GNU grep's -q option. Shell scripts intended to be portable to traditional grep
       should avoid both -q and -s and should redirect output to /dev/null instead.

   -U, --binary
       Treat the file(s) as binary. 
       By default, under MS-DOS and MS-Windows, grep guesses the file type by looking at
       the contents of the first 32KB read from the file. If grep decides the file is a
       text file, it strips the CR characters from the original file contents
       (to make regular expressions with ^ and $ work correctly).
       Specifying -U overrules this guesswork, causing all files to be read and passed
       to the matching mechanism verbatim; if the file is a text file with CR/LF pairs
       at the end of each line, this will cause some regular expressions to fail.
       This option has no effect on platforms other than MS-DOS and MS-Windows.
 
   -u
   --unix-byte-offsets
       Report Unix-style byte offsets.
       This switch causes grep to report byte offsets as if the file were a Unix-style text
       file, i.e. with CR characters stripped off. This will produce results identical to
       running grep on a Unix machine.
       This option has no effect unless -b option is also used; it has no effect on
       platforms other than MS-DOS and MS-Windows.

   -V
   --version
       Print the version number of grep to standard error.
       This version number should be included in all bug reports (see below). 
   -v
   --invert-match
       Invert the sense of matching, to select non-matching lines. 
   -w
   --word-regexp
       Select only those lines containing matches that form whole words.
       The test is that the matching substring must either be at the beginning of
       the line, or preceded by a non-word constituent character. Similarly, it
       must be either at the end of the line or followed by a non-word constituent
       character. Word-constituent characters are letters, digits, and the underscore.

   -x
   --line-regexp
       Select only those matches that exactly match the whole line. 
   -y
       Obsolete synonym for -i.
   -Z
   --null
       Output a zero byte (the ASCII NUL character) instead of the character that
       normally follows a file name. For example, grep -lZ outputs a zero byte after
       each file name instead of the usual newline.
       This option makes the output unambiguous, even in the presence of file names
       containing unusual characters like newlines.
       This option can be used with commands like find -print0, perl -0, sort -z, and
       xargs -0 to process arbitrary file names, even those that contain newline characters. </pre>
<h2>Environment variables</h2>
<blockquote>
<p>Grep's behavior can be affected by setting the following environment variables<br>
</p>
<pre>
GREP_OPTIONS                 - default options
GREP_COLOR                   - The marker for highlighting
LC_ALL, LC_COLLATE, LANG     - These variables specify the LC_COLLATE locale,
                               which determines the collating sequence used
                               to interpret range expressions like [a-z]. 
LC_ALL, LC_COLLATE, LANG<br>    These variables specify the LC_MESSAGES locale, which determines the
    language used for messages. The default C locale uses American English messages. 
LC_ALL, LC_CTYPE, LANG       - specify the LC_CTYPE locale, which determines the type of
                               characters, e.g., which characters are whitespace.
LC_ALL, LC_MESSAGES, LANG
    These variables specify the LC_MESSAGES locale, which determines the
    language that grep uses for messages. The default C locale uses American English messages. 
POSIXLY_CORRECT              - Posix behaviour
_<i>N</i>_GNU_nonoption_argv_flags_
    If the ith character of this environment variable's value is 1, do not consider
    the ith operand of grep to be an option, ( <i>N</i> is grep's numeric process ID)

see `info grep' for more</pre></blockquote>
<p><span class="body">Grep stands for:  Global Regular Expression Print.</span></p>
<p><span class="code">grep</span> comes from the <span class="code">ed</span> command to print all lines matching a certain pattern <span class="code">g/re/p</span> where &quot;<span class="code">re</span>&quot; is a &quot;regular expression&quot;. </p>
<h2>Exit Status</h2>
<blockquote>
<p>   grep exits with one of the following values:<br>
</p>
<pre>
   0     One or more lines were selected.
   1     No lines were selected.
   >1    An error occurred - syntax error in <i>pattern</i>, inaccessible input files, or other system error.
</pre>
<p>In other words a failure to find a matching item is reported as an error (1) </p>
<p>The `-v' option can be used to effectively invert the exit status.</p>
</blockquote>
<p><b>Examples</b></p>
<p>Search the file example.txt, including binary data (-a) for the string 'hunting the snark':</p>
<p class="code">$ sudo grep -a 'hunting the snark' example.txt</p>
<p>Search the whole partition (/sda1), including binary data(-a) for the string '<i>hunting the snark</i>' return all the lines starting 25 <b>B</b>efore the text found and 50 lines <b>A</b>fter the matching text found. <br>
This can be a way to discover fragments of deleted files but is very slow:</p>
<p><span class="code">$ grep -a -B 25 -A 50 'hunting the snark' /dev/sda1</span> &gt; results.txt</p>
<p>Search the file wordlist.txt  for any lines that <b>don't </b>include at least one vowel:</p>
<p class="code">$ grep -v [aeiou] wordlist.txt</p>
<p>Remove lines from <span class="code">invoices.txt</span> if they appear in <span class="code">paid.txt</span>:</p>
<p class="code">$ grep -F -x -v -f paid.txt invoices.txt &gt;paidinvoices.txt</p>
<p><i class="quote">&quot;I understand that change is frightening for people, especially if there's nothing to go to. It's best to stay where you are.
I understand that&quot; ~ <a href="https://www.bbc.co.uk/politics97/diana/panorama.html">Princess Diana</a> </i></p>
<p><b>Related linux commands:</b></p>
<p><a href="egrep.html">egrep</a> - Search file(s) for lines that match an extended 
expression<br>
<a href="fgrep.html">fgrep</a> - Search file(s) for lines that match a fixed 
string<br>
<a href="pkill.html">pgrep</a> - find  signal processes by name<br>
<a href="http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">Why GNU grep is fast</a> - comparison with BSD grep<br>
<a href="find.html">find</a> - Search for files that meet a desired criteria<br>
<a href="awk.html">gawk</a> - Find and Replace text within file(s)<br>
<a href="locate.html">locate</a> - Find files<br>
<a href="sed.html">sed</a> - Stream Editor - Find and Replace text within file(s)  <br>
<a href="tr.html">tr</a> - Translate, squeeze, and/or delete characters <br>
<a href="whereis.html">whereis</a> - Search the user's <span class="code">$path</span>, man pages and source files for a program<br>
<a href="https://beyondgrep.com/">BeyondGrep : ack</a> - A tool like grep, optimized for programmers <br>
Equivalent Windows commands: <a href="../nt/qgrep.html">QGREP</a> / <a href="../nt/findstr.html">FINDSTR</a> - Search for strings in files </p><!-- #BeginLibraryItem "/Library/foot_bash.lbi" --><p><script async src="../../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
<!-- bash300 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-6140977852749469"
     data-ad-slot="4615356305"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></p>
<hr>
<div id=bl class="footer">&nbsp;</div>
<div id=br class="footer, tagline">Copyright &copy; <a href="../index.html">SS64.com</a> 1999-2018<br>
Some rights reserved</div><!-- #EndLibraryItem --></body>

<!-- Mirrored from ss64.com/bash/grep.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Nov 2018 11:39:34 GMT -->
</html>
